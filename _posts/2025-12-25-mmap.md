---
title: "Linux drvice driver: mmap"
date: 2025-12-25
categories:
  - linux-kernel
tags:
  - mmap 
  - remap_pfn_range
  - io_remap_pfn_range
  - kernel
---

# 1. system call mmap() 
a **system call that maps files or devices into memory**, allowing direct memory access. In Linux drivers, you implement `mmap` in the `file_operations` structure to expose device memory to userspace.

## üìã User-Space `mmap()` Parameters

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

| Parameter | Type | Description | Common Values |
|-----------|------|-------------|---------------|
| **`addr`** | `void *` | **Hint address** for mapping (usually NULL) | `NULL` (let kernel choose), specific address |
| **`length`** | `size_t` | **Mapping size** in bytes | Device memory size (e.g., 4096, 65536) |
| **`prot`** | `int` | **Protection flags** (bitwise OR) | `PROT_READ`, `PROT_WRITE`, `PROT_EXEC`, `PROT_NONE` |
| **`flags`** | `int` | **Mapping type flags** (bitwise OR) | `MAP_SHARED`, `MAP_PRIVATE`, `MAP_FIXED`, `MAP_ANONYMOUS` |
| **`fd`** | `int` | **File descriptor** of device/file | Open file descriptor from `open()` |
| **`offset`** | `off_t` | **Offset into file/device** (must be page-aligned) | 0 for whole device, page multiple (4096*n) |

### Protection Flags (`prot`)
| Flag | Description | Driver Implication |
|------|-------------|-------------------|
| `PROT_READ` | Pages can be read | Must allow read operations |
| `PROT_WRITE` | Pages can be written | Must allow write operations |
| `PROT_EXEC` | Pages can be executed | Rare for devices, usually not allowed |
| `PROT_NONE` | Pages cannot be accessed | Used for guard pages |

### Mapping Flags (`flags`)
| Flag | Description | Typical Use |
|------|-------------|-------------|
| `MAP_SHARED` | **Shared mapping** (changes visible to others) | **Device drivers** (shared with hardware) |
| `MAP_PRIVATE` | Private copy-on-write mapping | Process-private memory |
| `MAP_FIXED` | Use exact `addr` (dangerous) | Specialized applications |
| `MAP_ANONYMOUS` | Not backed by file (ignore `fd`) | `malloc()` implementations |

## üîß Driver-Side `mmap` Implementation

In your driver, you implement the `mmap` callback:

```c
int (*mmap) (struct file *filp, struct vm_area_struct *vma);
```

### Key `vm_area_struct` (VMA) Fields
| Field | Type | Description |
|-------|------|-------------|
| `vm_start` | `unsigned long` | **Start user virtual address** (set by kernel) |
| `vm_end` | `unsigned long` | **End user virtual address** (set by kernel) |
| `vm_pgoff` | `unsigned long` | **Offset in pages** (from `offset` parameter) |
| `vm_flags` | `unsigned long` | **Protection flags** (from `prot` & `flags`) |
| `vm_page_prot` | `pgprot_t` | **Page protection** (driver may modify) |
| `vm_ops` | `struct vm_operations_struct *` | **VMA operations** (optional callbacks) |

## üìù Complete Driver `mmap` Example

Here's a full example for a PCIe device with a memory-mapped BAR:

```c
#include <linux/mm.h>
#include <linux/pci.h>

/* VMA operations (optional) */
static void my_vma_open(struct vm_area_struct *vma)
{
    printk(KERN_DEBUG "VMA opened: 0x%lx-0x%lx\n", 
           vma->vm_start, vma->vm_end);
}

static void my_vma_close(struct vm_area_struct *vma)
{
    printk(KERN_DEBUG "VMA closed: 0x%lx-0x%lx\n", 
           vma->vm_start, vma->vm_end);
}

/* vm_operations_struct */
static const struct vm_operations_struct my_vm_ops = {
    .open = my_vma_open,
    .close = my_vma_close,
};

/* Driver mmap implementation */
static int my_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct my_device *dev = filp->private_data;
    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
    unsigned long size = vma->vm_end - vma->vm_start;
    unsigned long pfn;
    
    /* 1. VALIDATE parameters */
    /* Check if offset is within device memory */
    if (offset >= dev->mem_size) {
        return -EINVAL;  /* Offset out of range */
    }
    
    /* Check if mapping fits in remaining device memory */
    if (size > dev->mem_size - offset) {
        return -EINVAL;  /* Mapping too large */
    }
    
    /* Check user requested permissions are supported */
    if ((vma->vm_flags & VM_WRITE) && !dev->writeable) {
        return -EACCES;  /* Write requested but not supported */
    }
    
    /* 2. CALCULATE physical address */
    /* For PCIe BAR memory (already mapped with ioremap) */
    pfn = (dev->bar_phys + offset) >> PAGE_SHIFT;
    
    /* Alternative: remap kernel virtual address */
    /* pfn = vmalloc_to_pfn(dev->kernel_buffer + offset); */
    
    /* 3. SETUP proper caching for device memory */
    /* Device memory should usually be uncached */
    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
    
    /* For frame buffers, use write-combined */
    /* vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot); */
    
    /* 4. PREVENT swapping and core dumps */
    vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
    vma->vm_flags |= VM_LOCKED;  /* Lock in memory (optional) */
    
    /* 5. SET VMA operations */
    vma->vm_ops = &my_vm_ops;
    
    /* 6. CREATE the mapping */
    if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot)) {
        return -EAGAIN;  /* Mapping failed */
    }
    
    /* 7. STORE device pointer in VMA (optional) */
    vma->vm_private_data = dev;
    
    return 0;  /* Success */
}

/* File operations structure */
static const struct file_operations my_fops = {
    .owner = THIS_MODULE,
    .mmap = my_mmap,
    .open = my_open,
    .release = my_release,
    /* ... other operations ... */
};
```

## üéØ Common `mmap` Use Cases in Drivers

### 1. **PCIe/PCI Device BAR Memory**
```c
/* Mapping a PCIe BAR for userspace DMA */
static int pcie_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct pcie_dev *dev = filp->private_data;
    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
    
    /* BAR0 is 16MB memory region */
    if (offset >= 16 * 1024 * 1024)
        return -EINVAL;
    
    /* Map physical BAR address to userspace */
    return remap_pfn_range(vma, vma->vm_start,
                          (dev->bar0_phys + offset) >> PAGE_SHIFT,
                          vma->vm_end - vma->vm_start,
                          pgprot_noncached(vma->vm_page_prot));
}
```

### 2. **Frame Buffer Device (Write-Combined)**
```c
/* Graphics card frame buffer */
static int fb_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct fb_device *fb = filp->private_data;
    
    vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
    vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
    
    return remap_pfn_range(vma, vma->vm_start,
                          fb->fb_phys >> PAGE_SHIFT,
                          fb->fb_size,
                          vma->vm_page_prot);
}
```

### 3. **DMA Buffer Sharing (dma-buf)**
```c
/* Export DMA buffer for userspace/other drivers */
static int dma_buf_mmap(struct dma_buf *dmabuf,
                       struct vm_area_struct *vma)
{
    /* Use dma-buf infrastructure */
    return dma_buf_mmap(dmabuf, vma, 0);
}
```

## ‚ö†Ô∏è Critical Considerations & Pitfalls

### **Memory Caching Modes**
| Mode | Function | Use Case | Performance |
|------|----------|----------|-------------|
| **Cached** | (default) | Normal RAM | Highest |
| **Uncached** | `pgprot_noncached()` | **Device registers** | Very low |
| **Write-Combined** | `pgprot_writecombine()` | Frame buffers, bulk data | High write throughput |

### **Security & Validation**
```c
/* ALWAYS validate parameters */
static int safe_mmap(struct file *filp, struct vm_area_struct *vma)
{
    /* Check for malicious offset/size combinations */
    if (vma->vm_pgoff > (MAX_OFFSET >> PAGE_SHIFT))
        return -EINVAL;
    
    /* Prevent mapping too much memory */
    if ((vma->vm_end - vma->vm_start) > MAX_MAP_SIZE)
        return -EINVAL;
    
    /* Check permissions */
    if ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED))
        return -EINVAL;  /* Private write mapping not allowed */
    
    /* ... rest of mmap ... */
}
```

### **Common Errors & Solutions**
| Error | Likely Cause | Solution |
|-------|--------------|----------|
| **`-EINVAL`** | Invalid parameters | Validate offset, size, permissions |
| **`-EACCES`** | Permission denied | Check `vm_flags` against device capabilities |
| **`-EAGAIN`** | `remap_pfn_range()` failed | Check physical address, page protection |
| **SIGBUS** | Accessed unmapped area | Ensure entire mapped region is valid |

## üîç Debugging `mmap` Issues

1. **Check `/proc/[pid]/maps`** for user mappings:
   ```bash
   cat /proc/self/maps | grep mydevice
   ```

2. **Add debug prints**:
   ```c
   printk(KERN_DEBUG "mmap: offset=%lu, size=%lu, flags=%lx\n",
          vma->vm_pgoff << PAGE_SHIFT,
          vma->vm_end - vma->vm_start,
          vma->vm_flags);
   ```

3. **Verify physical addresses**:
   ```c
   printk(KERN_DEBUG "Physical: 0x%llx, PFN: 0x%lx\n",
          dev->bar_phys, pfn);
   ```

## üìä Performance Optimization

1. **Use huge pages** (if supported):
   ```c
   if (size >= 2 * 1024 * 1024) {  /* 2MB */
       vma->vm_flags |= VM_HUGETLB;
   }
   ```

2. **Prefault pages** for real-time applications:
   ```c
   /* Map all pages immediately */
   for (addr = vma->vm_start; addr < vma->vm_end; addr += PAGE_SIZE) {
       if (vm_insert_page(vma, addr, pfn_to_page(pfn++)))
           return -EAGAIN;
   }
   ```

**Key takeaway**: Driver `mmap` implementation must **validate all parameters**, **set appropriate caching**, and **use the correct remapping function** for your memory type (physical, vmalloc, kmap, etc.).


# 2. `io_remap_pfn_range()` 
is a **specialized version of `remap_pfn_range()` specifically for mapping I/O memory** (uncached/write-combined) into user space. It handles architecture-specific details for non-cached mappings.

## üìã Function Signature

```c
int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
                       unsigned long pfn, unsigned long size, pgprot_t prot);
```

| Parameter | Type | Description | Typical Value |
|-----------|------|-------------|---------------|
| **`vma`** | `struct vm_area_struct *` | **Virtual Memory Area** describing the user mapping | Passed from driver's `mmap()` callback |
| **`addr`** | `unsigned long` | **Starting user virtual address** for mapping | Usually `vma->vm_start` |
| **`pfn`** | `unsigned long` | **Page Frame Number** (physical address >> PAGE_SHIFT) | Device physical address converted to PFN |
| **`size`** | `unsigned long` | **Size of mapping in bytes** | Usually `vma->vm_end - vma->vm_start` |
| **`prot`** | `pgprot_t` | **Page protection flags** | Modified caching attributes (noncached/write-combined) |

## üîç Key Differences from `remap_pfn_range()`

| Aspect | `remap_pfn_range()` | `io_remap_pfn_range()` |
|--------|---------------------|------------------------|
| **Primary Use** | System RAM, cached memory | **I/O memory**, device registers |
| **Caching** | Uses `prot` as-is | **Forces uncached semantics** |
| **Memory Type** | Normal cacheable | **UC (Uncached)** or **WC (Write-Combined)** |
| **TLB Handling** | Standard | Architecture-specific for I/O |
| **When to Use** | kmalloc/vmalloc memory | **ioremap'ed device memory** |

## üìù Complete Usage Example

```c
#include <linux/mm.h>
#include <linux/io.h>

/* Driver mmap for PCIe device with I/O memory */
static int pcie_device_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct pcie_device *dev = filp->private_data;
    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
    unsigned long size = vma->vm_end - vma->vm_start;
    unsigned long pfn;
    int ret;
    
    /* 1. VALIDATE the request */
    if (offset >= dev->bar_size) {
        dev_err(dev->device, "Offset 0x%lx beyond BAR size 0x%lx\n",
                offset, dev->bar_size);
        return -EINVAL;
    }
    
    if (size > dev->bar_size - offset) {
        dev_err(dev->device, "Size 0x%lx too large (max 0x%lx)\n",
                size, dev->bar_size - offset);
        return -EINVAL;
    }
    
    /* 2. CALCULATE PFN from physical address */
    /* Assuming dev->bar_phys is the physical base address of the BAR */
    pfn = (dev->bar_phys + offset) >> PAGE_SHIFT;
    
    /* 3. SET proper I/O memory attributes */
    /* Critical: I/O memory should NOT be cached */
    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
    
    /* Alternative for frame buffers: write-combined */
    /* vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot); */
    
    /* 4. PREVENT undesirable operations on I/O memory */
    vma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;
    
    /* 5. PERFORM the I/O remapping */
    ret = io_remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot);
    if (ret) {
        dev_err(dev->device, "io_remap_pfn_range failed: %d\n", ret);
        return ret;
    }
    
    dev_dbg(dev->device, "Mapped 0x%lx bytes at user VA 0x%lx (PFN 0x%lx)\n",
            size, vma->vm_start, pfn);
    
    return 0;
}
```

## üéØ Common Use Cases with Code Examples

### **1. PCIe Device with Control Registers**
```c
static int pcie_ctrl_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct pcie_ctrl *ctrl = filp->private_data;
    
    /* Only allow mapping the control register region (first 4KB) */
    if (vma->vm_pgoff != 0 || 
        (vma->vm_end - vma->vm_start) > PAGE_SIZE) {
        return -EINVAL;
    }
    
    /* Control registers must be uncached for immediate visibility */
    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
    vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
    
    return io_remap_pfn_range(vma, vma->vm_start,
                             ctrl->regs_phys >> PAGE_SHIFT,
                             PAGE_SIZE, vma->vm_page_prot);
}
```

### **2. DMA Buffer for High-Performance I/O**
```c
static int dma_buffer_mmap(struct file *filp, struct vm_area_struct *vma)
{
    struct dma_device *dev = filp->private_data;
    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
    dma_addr_t dma_addr;
    
    /* Get DMA address for this buffer region */
    dma_addr = dev->dma_addr + offset;
    
    /* DMA buffers typically use write-combined for performance */
    vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
    
    /* Mark as I/O memory */
    vma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;
    
    return io_remap_pfn_range(vma, vma->vm_start,
                             dma_addr >> PAGE_SHIFT,
                             vma->vm_end - vma->vm_start,
                             vma->vm_page_prot);
}
```

### **3. Frame Buffer Device**
```c
static int fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
{
    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
    unsigned long mmio_pgoff;
    struct fb_device *fb = info->par;
    
    /* Frame buffer memory (write-combined for performance) */
    vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
    vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
    
    return io_remap_pfn_range(vma, vma->vm_start,
                             (fb->fb_phys + offset) >> PAGE_SHIFT,
                             vma->vm_end - vma->vm_start,
                             vma->vm_page_prot);
}
```

## ‚ö†Ô∏è Critical Considerations

### **PFN Calculation Gotchas**
```c
/* WRONG: Using virtual address from ioremap() */
pfn = virt_to_phys(dev->regs_virt) >> PAGE_SHIFT;  // May work but wrong!

/* WRONG: Using kernel virtual address directly */
pfn = vmalloc_to_pfn(dev->kernel_buf);  // For vmalloc memory, not I/O!

/* CORRECT: Using physical address of device memory */
pfn = (dev->bar_phys + offset) >> PAGE_SHIFT;

/* CORRECT: If you only have bus address (for DMA) */
pfn = (dma_addr_to_phys(dev->dma_addr) + offset) >> PAGE_SHIFT;
```

### **Architecture-Specific Behavior**
```c
/* x86-specific: Different memory types */
#define _PAGE_CACHE_MODE_UC      0  /* Uncached */
#define _PAGE_CACHE_MODE_WC      1  /* Write-combined */
#define _PAGE_CACHE_MODE_WT      4  /* Write-through */

/* ARM-specific: Memory attributes */
#define pgprot_noncached(prot) \
    __pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_UNCACHED)

/* Use architecture-independent helpers */
#include <linux/io.h>
vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);  // Portable
```

### **Error Handling Patterns**
```c
static int robust_io_remap(struct file *filp, struct vm_area_struct *vma)
{
    int ret;
    
    ret = io_remap_pfn_range(vma, vma->vm_start, pfn, size, prot);
    
    switch (ret) {
    case 0:
        /* Success */
        break;
    case -EAGAIN:
        /* Temporary failure, should retry */
        dev_warn(dev, "Temporary mapping failure, retrying\n");
        /* Could implement retry logic here */
        break;
    case -EFAULT:
        /* Invalid address */
        dev_err(dev, "Invalid physical address 0x%lx\n", pfn << PAGE_SHIFT);
        break;
    default:
        /* Other errors */
        dev_err(dev, "io_remap_pfn_range failed: %d\n", ret);
        break;
    }
    
    return ret;
}
```

## üîß Debugging `io_remap_pfn_range` Issues

### **1. Check Mapping in /proc**
```bash
# Check user process mappings
cat /proc/$PID/maps | grep -i mydevice

# Check kernel page tables (requires debug kernel)
cat /proc/kpageflags | grep -A5 -B5 $PFN
```

### **2. Add Debug Prints**
```c
dev_dbg(dev->device, 
        "io_remap_pfn_range: vma=%px [%lx-%lx], pfn=%lx, size=%lx, prot=%lx\n",
        vma, vma->vm_start, vma->vm_end, pfn, size,
        pgprot_val(vma->vm_page_prot));
```

### **3. Validate Physical Address**
```c
/* Ensure physical address is valid I/O memory */
if (!pfn_valid(pfn)) {
    /* This is expected for I/O memory - pfn_valid returns false */
    dev_dbg(dev, "PFN 0x%lx is I/O memory (not system RAM)\n", pfn);
}

/* Check if address is within expected I/O range */
if (pfn < (dev->iomem_start >> PAGE_SHIFT) ||
    pfn >= (dev->iomem_end >> PAGE_SHIFT)) {
    dev_err(dev, "PFN 0x%lx outside I/O range [0x%lx-0x%lx)\n",
            pfn, dev->iomem_start, dev->iomem_end);
    return -EINVAL;
}
```

## üìä Performance Implications

| Memory Type | Latency | Throughput | Use Case |
|-------------|---------|------------|----------|
| **Uncached (UC)** | Very High | Low | Device registers, control |
| **Write-Combined (WC)** | High | **High writes** | Frame buffers, DMA |
| **Cached (WB)** | Low | High | System RAM |

```c
/* Choose based on access pattern */
if (is_control_region(offset)) {
    /* Registers: every write must be immediate */
    prot = pgprot_noncached(prot);
} else if (is_frame_buffer(offset)) {
    /* Frame buffer: write performance critical */
    prot = pgprot_writecombine(prot);
} else {
    /* Default to uncached for device memory */
    prot = pgprot_noncached(prot);
}
```

## üéØ Summary

**Key points about `io_remap_pfn_range()`:**
1. **Use for I/O memory only** (device registers, frame buffers, DMA regions)
2. **Always set proper caching** (`pgprot_noncached()` or `pgprot_writecombine()`)
3. **Set VM_IO flag** to prevent undesirable operations
4. **PFN must be physical address** of device memory, not kernel virtual address
5. **Validate offset/size** to stay within device memory region

**Common mistake**: Using `io_remap_pfn_range()` for system RAM (use `remap_pfn_range()` instead) or forgetting to set uncached protection for device registers.



