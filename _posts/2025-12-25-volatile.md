---
title: volatile
date: 2025-12-25
categories:
  - linux-kernel
tags:
  - volatile
  - kernel
**Yes, you absolutely must use `volatile` when accessing device-mapped memory in userspace. This is critical and not optional.** Here's why and how:

## üö® **Why Volatile is Mandatory**

Device memory behaves **differently from normal RAM**:
- **Read side effects**: Reading a register may clear its contents
- **Write side effects**: Writing may trigger device actions
- **External changes**: Hardware can change values independently
- **No caching assumptions**: Device reads/writes must happen every time

**Without `volatile`**, the compiler can legally:
```c
// Without volatile - COMPILER CAN OPTIMIZE THIS WRONG
uint32_t *reg = (uint32_t*)mmap_addr;
*reg = 0x1;          // Write to enable
// Compiler might remove "redundant" writes
*reg = 0x1;          // Same value? Might be optimized away!

uint32_t status = *reg;  // Read status
status = *reg;           // Same read? Might use cached value!
```

## ‚úÖ **Correct Userspace Access Patterns**

### **Basic Volatile Declaration**
```c
#include <stdint.h>
#include <sys/mman.h>

int main() {
    int fd = open("/dev/mydevice", O_RDWR);
    void *addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, 
                      MAP_SHARED, fd, 0);
    
    // CRITICAL: Add volatile qualifier
    volatile uint32_t *device_regs = (volatile uint32_t*)addr;
    
    // Now accesses won't be optimized away
    device_regs[0] = 0x12345678;    // Write happens
    uint32_t val = device_regs[1];  // Read happens
    
    munmap(addr, 4096);
    close(fd);
    return 0;
}
```

### **Structured Access for Device Registers**
```c
typedef struct __attribute__((packed)) {
    volatile uint32_t control;      // Offset 0x00
    volatile uint32_t status;       // Offset 0x04
    volatile uint32_t data;         // Offset 0x08
    volatile uint32_t interrupt;    // Offset 0x0C
} device_regs_t;

void access_device(void *mmap_addr) {
    device_regs_t *regs = (device_regs_t*)mmap_addr;
    
    // These accesses are guaranteed to happen
    regs->control = 0x1;           // Enable device
    while (!(regs->status & 0x1))  // Poll status (each read happens)
        ;
    regs->data = 0xABCD;           // Write data
}
```

## üîç **Detailed Examples by Access Pattern**

### **1. Register Polling (Must Use Volatile)**
```c
// CORRECT: With volatile
int wait_for_ready(volatile uint32_t *status_reg) {
    int timeout = 1000000;
    
    // Each read actually happens - critical for polling
    while (--timeout > 0) {
        if (*status_reg & READY_BIT)  // Hardware status checked every time
            return 0;
        usleep(10);
    }
    return -ETIMEDOUT;
}

// WRONG: Without volatile
int wait_for_ready_broken(uint32_t *status_reg) {
    // Compiler might hoist read out of loop:
    uint32_t cached = *status_reg;  // Read once
    while (--timeout > 0) {
        if (cached & READY_BIT)     // Always checks cached value!
            return 0;
        usleep(10);
    }
    return -ETIMEDOUT;
}
```

### **2. Sequence-Dependent Writes**
```c
// Device requires exact write sequence
void program_device(volatile uint32_t *regs) {
    // All writes MUST happen in this order
    regs[CMD_REG] = CMD_UNLOCK;     // Unlock command
    regs[DATA_REG] = 0xAA55AA55;    // Data word 1
    regs[DATA_REG] = 0x55AA55AA;    // Data word 2
    regs[CMD_REG] = CMD_PROGRAM;    // Program command
    // Without volatile, compiler could reorder or eliminate!
}
```

### **3. Memory-Mapped FIFO/Buffer**
```c
// Reading from a hardware FIFO
ssize_t read_fifo(volatile uint8_t *fifo_data, 
                  volatile uint32_t *fifo_status,
                  uint8_t *buffer, size_t size) {
    ssize_t bytes_read = 0;
    
    while (bytes_read < size) {
        // Must read status every iteration
        if (!(*fifo_status & FIFO_HAS_DATA))
            break;
            
        // Read from FIFO - each read consumes data
        buffer[bytes_read++] = *fifo_data;
    }
    
    return bytes_read;
}
```

## ‚ö†Ô∏è **Common Pitfalls & Solutions**

### **Pitfall 1: Mixing Volatile and Non-Volatile**
```c
// WRONG: Cast loses volatile
void *addr = mmap(...);
uint32_t *reg = (uint32_t*)addr;  // Lost volatile!

// CORRECT: Maintain volatile through all pointers
volatile void *addr = mmap(...);
volatile uint32_t *reg = (volatile uint32_t*)addr;

// Also correct: One-step cast
volatile uint32_t *reg = (volatile uint32_t*)mmap(...);
```

### **Pitfall 2: Function Parameters Losing Volatile**
```c
// WRONG: Volatile not propagated
void write_reg(uint32_t *reg, uint32_t value) {
    *reg = value;  // Compiler might optimize
}

// CORRECT: Preserve volatile in parameters
void write_reg(volatile uint32_t *reg, uint32_t value) {
    *reg = value;  // Write will happen
}

// Usage:
write_reg((volatile uint32_t*)mmap_addr, 0x1234);
```

### **Pitfall 3: Structure Members Without Volatile**
```c
// WRONG: Structure doesn't preserve volatile
typedef struct {
    uint32_t *regs;  // Not volatile
} device_ctx;

// CORRECT: Embed volatile in type
typedef struct {
    volatile uint32_t *regs;
} device_ctx;

// Even better: Typedef volatile pointer
typedef volatile uint32_t vreg32_t;
vreg32_t *regs = (vreg32_t*)mmap_addr;
```

## üìä **Volatile vs Other Concerns**

| Concern | Volatile Addresses? | Additional Needs |
|---------|-------------------|------------------|
| **Compiler optimization** | ‚úÖ Yes - prevents removal/reordering | None |
| **CPU reordering** | ‚ùå No - volatile doesn't prevent CPU reordering | **Memory barriers** needed |
| **Cache coherency** | ‚ùå No - volatile doesn't control caching | **Uncached mappings** in kernel |
| **Atomicity** | ‚ùå No - volatile doesn't guarantee atomicity | **Atomic operations** or locks |

### **Adding Memory Barriers (When Needed)**
```c
#include <stdatomic.h>

// For multi-core systems with weak memory ordering
void safe_device_write(volatile uint32_t *reg, uint32_t value) {
    *reg = value;
    // Ensure write completes before continuing
    atomic_thread_fence(memory_order_seq_cst);
}

// GCC/Clang built-in barriers
void gcc_memory_barrier(volatile uint32_t *reg, uint32_t value) {
    *reg = value;
    __sync_synchronize();  // Full memory barrier
}
```

## üõ†Ô∏è **Complete Safe Userspace Driver Example**

```c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <errno.h>

typedef volatile uint32_t vreg32_t;

struct pcie_regs {
    vreg32_t control;
    vreg32_t status;
    vreg32_t data_in;
    vreg32_t data_out;
    vreg32_t interrupt;
};

int main() {
    int fd = open("/dev/pcie_device", O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }
    
    // Map device memory (uncached in kernel driver)
    void *map = mmap(NULL, 4096, PROT_READ|PROT_WRITE, 
                     MAP_SHARED, fd, 0);
    if (map == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }
    
    // Cast with volatile
    struct pcie_regs *regs = (struct pcie_regs*)map;
    
    // 1. Reset device
    regs->control = 0x1;
    
    // 2. Wait for ready (volatile ensures each read)
    int timeout = 1000;
    while (timeout-- > 0) {
        if (regs->status & 0x1)  // Each read hits hardware
            break;
        usleep(1000);
    }
    
    if (timeout <= 0) {
        fprintf(stderr, "Device timeout\n");
        goto cleanup;
    }
    
    // 3. Write data (volatile ensures write happens)
    regs->data_out = 0xDEADBEEF;
    
    // 4. Start operation
    regs->control = 0x2;
    
    // 5. Read result
    uint32_t result = regs->data_in;  // Volatile read
    
    printf("Device result: 0x%08X\n", result);
    
cleanup:
    munmap(map, 4096);
    close(fd);
    return 0;
}
```

## üìù **Summary of Rules**

1. **Always use `volatile`** for device memory pointers in userspace
2. **Cast early and consistently**: `volatile uint32_t* ptr = (volatile uint32_t*)mmap_addr;`
3. **Propagate `volatile`** through function parameters and structures
4. **Remember volatile only affects compiler**, not CPU ordering or caching
5. **For multi-core systems**, add memory barriers when device requires ordering

**Bottom line**: If you're accessing hardware registers through mmap in userspace, **`volatile` is non-negotiable**. It's the minimum requirement to ensure your accesses actually reach the hardware.

For more complex scenarios (DMA buffers, shared memory with kernel), you may need additional synchronization, but `volatile` is always step one.

